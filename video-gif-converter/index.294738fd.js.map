{"mappings":"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","sources":["<anon>","script.js","node_modules/@ffmpeg/ffmpeg/dist/umd/ffmpeg.js","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/universalModuleDefinition","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/bootstrap","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/runtime/define property getters","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/runtime/get javascript chunk filename","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/runtime/global","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/runtime/hasOwnProperty shorthand","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/runtime/make namespace object","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/runtime/publicPath","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/webpack/runtime/jsonp chunk loading","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/dist/esm/const.js","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/dist/esm/utils.js","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/dist/esm/errors.js","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/dist/esm/classes.js","node_modules/@ffmpeg/ffmpeg/dist/umd/webpack:/FFmpegWASM/dist/esm/types.js","node_modules/@ffmpeg/util/dist/cjs/index.js","node_modules/@ffmpeg/util/dist/cjs/errors.js","node_modules/@ffmpeg/util/dist/cjs/const.js"],"sourcesContent":["// From the actual documentation\nvar $f3794c4d073fcecf$exports = {};\n!function(e, t) {\n    $f3794c4d073fcecf$exports = t();\n}(self, ()=>(()=>{\n        \"use strict\";\n        var e = {\n            m: {},\n            d: (t, s)=>{\n                for(var r in s)e.o(s, r) && !e.o(t, r) && Object.defineProperty(t, r, {\n                    enumerable: !0,\n                    get: s[r]\n                });\n            },\n            u: (e)=>e + \".ffmpeg.js\"\n        };\n        e.g = function() {\n            if (\"object\" == typeof globalThis) return globalThis;\n            try {\n                return this || new Function(\"return this\")();\n            } catch (e) {\n                if (\"object\" == typeof window) return window;\n            }\n        }(), e.o = (e, t)=>Object.prototype.hasOwnProperty.call(e, t), e.r = (e)=>{\n            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n                value: \"Module\"\n            }), Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            });\n        }, (()=>{\n            var t;\n            e.g.importScripts && (t = e.g.location + \"\");\n            var s = e.g.document;\n            if (!t && s && (s.currentScript && (t = s.currentScript.src), !t)) {\n                var r = s.getElementsByTagName(\"script\");\n                if (r.length) for(var a = r.length - 1; a > -1 && !t;)t = r[a--].src;\n            }\n            if (!t) throw new Error(\"Automatic publicPath is not supported in this browser\");\n            t = t.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\"), e.p = t;\n        })(), e.b = document.baseURI || self.location.href;\n        var t, s = {};\n        e.r(s), e.d(s, {\n            FFFSType: ()=>n,\n            FFmpeg: ()=>i\n        }), function(e) {\n            e.LOAD = \"LOAD\", e.EXEC = \"EXEC\", e.FFPROBE = \"FFPROBE\", e.WRITE_FILE = \"WRITE_FILE\", e.READ_FILE = \"READ_FILE\", e.DELETE_FILE = \"DELETE_FILE\", e.RENAME = \"RENAME\", e.CREATE_DIR = \"CREATE_DIR\", e.LIST_DIR = \"LIST_DIR\", e.DELETE_DIR = \"DELETE_DIR\", e.ERROR = \"ERROR\", e.DOWNLOAD = \"DOWNLOAD\", e.PROGRESS = \"PROGRESS\", e.LOG = \"LOG\", e.MOUNT = \"MOUNT\", e.UNMOUNT = \"UNMOUNT\";\n        }(t || (t = {}));\n        const r = (()=>{\n            let e = 0;\n            return ()=>e++;\n        })(), a = (new Error(\"unknown message type\"), new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\")), o = new Error(\"called FFmpeg.terminate()\");\n        new Error(\"failed to import ffmpeg-core.js\");\n        class i {\n            #e = null;\n            #t = {};\n            #s = {};\n            #r = [];\n            #a = [];\n            loaded = !1;\n            #o = ()=>{\n                this.#e && (this.#e.onmessage = ({ data: { id: e, type: s, data: r } })=>{\n                    switch(s){\n                        case t.LOAD:\n                            this.loaded = !0, this.#t[e](r);\n                            break;\n                        case t.MOUNT:\n                        case t.UNMOUNT:\n                        case t.EXEC:\n                        case t.FFPROBE:\n                        case t.WRITE_FILE:\n                        case t.READ_FILE:\n                        case t.DELETE_FILE:\n                        case t.RENAME:\n                        case t.CREATE_DIR:\n                        case t.LIST_DIR:\n                        case t.DELETE_DIR:\n                            this.#t[e](r);\n                            break;\n                        case t.LOG:\n                            this.#r.forEach((e)=>e(r));\n                            break;\n                        case t.PROGRESS:\n                            this.#a.forEach((e)=>e(r));\n                            break;\n                        case t.ERROR:\n                            this.#s[e](r);\n                    }\n                    delete this.#t[e], delete this.#s[e];\n                });\n            };\n            #i = ({ type: e, data: t }, s = [], o)=>this.#e ? new Promise((a, i)=>{\n                    const n = r();\n                    this.#e && this.#e.postMessage({\n                        id: n,\n                        type: e,\n                        data: t\n                    }, s), this.#t[n] = a, this.#s[n] = i, o?.addEventListener(\"abort\", ()=>{\n                        i(new DOMException(`Message # ${n} was aborted`, \"AbortError\"));\n                    }, {\n                        once: !0\n                    });\n                }) : Promise.reject(a);\n            on(e, t) {\n                \"log\" === e ? this.#r.push(t) : \"progress\" === e && this.#a.push(t);\n            }\n            off(e, t) {\n                \"log\" === e ? this.#r = this.#r.filter((e)=>e !== t) : \"progress\" === e && (this.#a = this.#a.filter((e)=>e !== t));\n            }\n            load = ({ classWorkerURL: s, ...r } = {}, { signal: a } = {})=>(this.#e || (this.#e = s ? new Worker(new URL(s, \"file:///Users/focus/Projects/ffmpeg.wasm/packages/ffmpeg/dist/esm/classes.js\"), {\n                    type: \"module\"\n                }) : new Worker(new URL(e.p + e.u(814), e.b), {\n                    type: void 0\n                }), this.#o()), this.#i({\n                    type: t.LOAD,\n                    data: r\n                }, void 0, a));\n            exec = (e, s = -1, { signal: r } = {})=>this.#i({\n                    type: t.EXEC,\n                    data: {\n                        args: e,\n                        timeout: s\n                    }\n                }, void 0, r);\n            ffprobe = (e, s = -1, { signal: r } = {})=>this.#i({\n                    type: t.FFPROBE,\n                    data: {\n                        args: e,\n                        timeout: s\n                    }\n                }, void 0, r);\n            terminate = ()=>{\n                const e = Object.keys(this.#s);\n                for (const t of e)this.#s[t](o), delete this.#s[t], delete this.#t[t];\n                this.#e && (this.#e.terminate(), this.#e = null, this.loaded = !1);\n            };\n            writeFile = (e, s, { signal: r } = {})=>{\n                const a = [];\n                return s instanceof Uint8Array && a.push(s.buffer), this.#i({\n                    type: t.WRITE_FILE,\n                    data: {\n                        path: e,\n                        data: s\n                    }\n                }, a, r);\n            };\n            mount = (e, s, r)=>this.#i({\n                    type: t.MOUNT,\n                    data: {\n                        fsType: e,\n                        options: s,\n                        mountPoint: r\n                    }\n                }, []);\n            unmount = (e)=>this.#i({\n                    type: t.UNMOUNT,\n                    data: {\n                        mountPoint: e\n                    }\n                }, []);\n            readFile = (e, s = \"binary\", { signal: r } = {})=>this.#i({\n                    type: t.READ_FILE,\n                    data: {\n                        path: e,\n                        encoding: s\n                    }\n                }, void 0, r);\n            deleteFile = (e, { signal: s } = {})=>this.#i({\n                    type: t.DELETE_FILE,\n                    data: {\n                        path: e\n                    }\n                }, void 0, s);\n            rename = (e, s, { signal: r } = {})=>this.#i({\n                    type: t.RENAME,\n                    data: {\n                        oldPath: e,\n                        newPath: s\n                    }\n                }, void 0, r);\n            createDir = (e, { signal: s } = {})=>this.#i({\n                    type: t.CREATE_DIR,\n                    data: {\n                        path: e\n                    }\n                }, void 0, s);\n            listDir = (e, { signal: s } = {})=>this.#i({\n                    type: t.LIST_DIR,\n                    data: {\n                        path: e\n                    }\n                }, void 0, s);\n            deleteDir = (e, { signal: s } = {})=>this.#i({\n                    type: t.DELETE_DIR,\n                    data: {\n                        path: e\n                    }\n                }, void 0, s);\n        }\n        var n;\n        return function(e) {\n            e.MEMFS = \"MEMFS\", e.NODEFS = \"NODEFS\", e.NODERAWFS = \"NODERAWFS\", e.IDBFS = \"IDBFS\", e.WORKERFS = \"WORKERFS\", e.PROXYFS = \"PROXYFS\";\n        }(n || (n = {})), s;\n    })());\n\n\nvar $8e792f90c5959bce$exports = {};\n\"use strict\";\nvar $8e792f90c5959bce$var$__awaiter = $8e792f90c5959bce$exports && $8e792f90c5959bce$exports.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty($8e792f90c5959bce$exports, \"__esModule\", {\n    value: true\n});\n$8e792f90c5959bce$exports.toBlobURL = $8e792f90c5959bce$exports.downloadWithProgress = $8e792f90c5959bce$exports.importScript = $8e792f90c5959bce$exports.fetchFile = void 0;\nvar $908c7b43e3e5d3cb$exports = {};\n\"use strict\";\nObject.defineProperty($908c7b43e3e5d3cb$exports, \"__esModule\", {\n    value: true\n});\n$908c7b43e3e5d3cb$exports.ERROR_INCOMPLETED_DOWNLOAD = $908c7b43e3e5d3cb$exports.ERROR_RESPONSE_BODY_READER = void 0;\n$908c7b43e3e5d3cb$exports.ERROR_RESPONSE_BODY_READER = new Error(\"failed to get response body reader\");\n$908c7b43e3e5d3cb$exports.ERROR_INCOMPLETED_DOWNLOAD = new Error(\"failed to complete download\");\n\n\nvar $3a36a17f95d15b42$exports = {};\n\"use strict\";\nObject.defineProperty($3a36a17f95d15b42$exports, \"__esModule\", {\n    value: true\n});\n$3a36a17f95d15b42$exports.HeaderContentLength = void 0;\n$3a36a17f95d15b42$exports.HeaderContentLength = \"Content-Length\";\n\n\nconst $8e792f90c5959bce$var$readFromBlobOrFile = (blob)=>new Promise((resolve, reject)=>{\n        const fileReader = new FileReader();\n        fileReader.onload = ()=>{\n            const { result: result } = fileReader;\n            if (result instanceof ArrayBuffer) resolve(new Uint8Array(result));\n            else resolve(new Uint8Array());\n        };\n        fileReader.onerror = (event)=>{\n            var _a, _b;\n            reject(Error(`File could not be read! Code=${((_b = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.code) || -1}`));\n        };\n        fileReader.readAsArrayBuffer(blob);\n    });\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */ const $8e792f90c5959bce$var$fetchFile = (file)=>$8e792f90c5959bce$var$__awaiter(void 0, void 0, void 0, function*() {\n        let data;\n        if (typeof file === \"string\") {\n            /* From base64 format */ if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) data = atob(file.split(\",\")[1]).split(\"\").map((c)=>c.charCodeAt(0));\n            else data = yield (yield fetch(file)).arrayBuffer();\n        } else if (file instanceof URL) data = yield (yield fetch(file)).arrayBuffer();\n        else if (file instanceof File || file instanceof Blob) data = yield $8e792f90c5959bce$var$readFromBlobOrFile(file);\n        else return new Uint8Array();\n        return new Uint8Array(data);\n    });\n$8e792f90c5959bce$exports.fetchFile = $8e792f90c5959bce$var$fetchFile;\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */ const $8e792f90c5959bce$var$importScript = (url)=>$8e792f90c5959bce$var$__awaiter(void 0, void 0, void 0, function*() {\n        return new Promise((resolve)=>{\n            const script = document.createElement(\"script\");\n            const eventHandler = ()=>{\n                script.removeEventListener(\"load\", eventHandler);\n                resolve();\n            };\n            script.src = url;\n            script.type = \"text/javascript\";\n            script.addEventListener(\"load\", eventHandler);\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        });\n    });\n$8e792f90c5959bce$exports.importScript = $8e792f90c5959bce$var$importScript;\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */ const $8e792f90c5959bce$var$downloadWithProgress = (url, cb)=>$8e792f90c5959bce$var$__awaiter(void 0, void 0, void 0, function*() {\n        var _a;\n        const resp = yield fetch(url);\n        let buf;\n        try {\n            // Set total to -1 to indicate that there is not Content-Type Header.\n            const total = parseInt(resp.headers.get($3a36a17f95d15b42$exports.HeaderContentLength) || \"-1\");\n            const reader = (_a = resp.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            if (!reader) throw $908c7b43e3e5d3cb$exports.ERROR_RESPONSE_BODY_READER;\n            const chunks = [];\n            let received = 0;\n            for(;;){\n                const { done: done, value: value } = yield reader.read();\n                const delta = value ? value.length : 0;\n                if (done) {\n                    if (total != -1 && total !== received) throw $908c7b43e3e5d3cb$exports.ERROR_INCOMPLETED_DOWNLOAD;\n                    cb && cb({\n                        url: url,\n                        total: total,\n                        received: received,\n                        delta: delta,\n                        done: done\n                    });\n                    break;\n                }\n                chunks.push(value);\n                received += delta;\n                cb && cb({\n                    url: url,\n                    total: total,\n                    received: received,\n                    delta: delta,\n                    done: done\n                });\n            }\n            const data = new Uint8Array(received);\n            let position = 0;\n            for (const chunk of chunks){\n                data.set(chunk, position);\n                position += chunk.length;\n            }\n            buf = data.buffer;\n        } catch (e) {\n            console.log(`failed to send download progress event: `, e);\n            // Fetch arrayBuffer directly when it is not possible to get progress.\n            buf = yield resp.arrayBuffer();\n            cb && cb({\n                url: url,\n                total: buf.byteLength,\n                received: buf.byteLength,\n                delta: 0,\n                done: true\n            });\n        }\n        return buf;\n    });\n$8e792f90c5959bce$exports.downloadWithProgress = $8e792f90c5959bce$var$downloadWithProgress;\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */ const $8e792f90c5959bce$var$toBlobURL = (url, mimeType, progress = false, cb)=>$8e792f90c5959bce$var$__awaiter(void 0, void 0, void 0, function*() {\n        const buf = progress ? yield (0, $8e792f90c5959bce$exports.downloadWithProgress)(url, cb) : yield (yield fetch(url)).arrayBuffer();\n        const blob = new Blob([\n            buf\n        ], {\n            type: mimeType\n        });\n        return URL.createObjectURL(blob);\n    });\n$8e792f90c5959bce$exports.toBlobURL = $8e792f90c5959bce$var$toBlobURL;\n\n\nffmpeg = new (0, $f3794c4d073fcecf$exports.FFmpeg)();\n//ffmpeg.on(\"log\", ({ message }) => { console.log(message); }); // If ffmpeg calls its log method, log that to the console.\nffmpeg.on(\"progress\", ({ progress: progress, time: time })=>{\n    document.getElementById('progress').textContent = `${(progress * 100).toFixed(2)} %, time: ${(time / 1000000).toFixed(2)} s`;\n}); // Show progress on the page.\nconst $c1ce9d969bfa6909$var$transcode = async ()=>{\n    /*  const baseURL = './';\r\n    await ffmpeg.load({\r\n      coreURL: await toBlobURL(`${baseURL}ffmpeg-core.js`, 'text/javascript'),\r\n      wasmURL: await toBlobURL(`${baseURL}ffmpeg-core.wasm`, 'application/wasm')\r\n    });*/ const baseURL = 'https://unpkg.com/@ffmpeg/core/dist/umd';\n    //const baseURL = \".\"\n    await ffmpeg.load({\n        coreURL: await (0, $8e792f90c5959bce$exports.toBlobURL)(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),\n        wasmURL: await (0, $8e792f90c5959bce$exports.toBlobURL)(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm')\n    });\n    // const file = await document.getElementById(\"fileInput\").files[0] ? await document.getElementById(\"fileInput\").files[0] : await processFetchedFile(); // With a default file for easy testing.\n    const file = await document.getElementById(\"fileInput\").files[0];\n    if (!file) return;\n    const { name: name } = file;\n    const outputFileType = document.getElementById('outputType').value;\n    document.getElementById('output').firstChild.replaceWith(document.createElement('span'));\n    await ffmpeg.writeFile(name, await (0, $8e792f90c5959bce$exports.fetchFile)(file));\n    document.getElementById('progress').textContent = 'Transcoding started';\n    console.log(`${new Date().toLocaleTimeString()} Transcoding started`);\n    await ffmpeg.exec([\n        '-i',\n        name,\n        `output.${outputFileType}`\n    ]);\n    document.getElementById('progress').textContent = 'Transcoding ended';\n    console.log(`${new Date().toLocaleTimeString()} Transcoding ended`);\n    const data = await ffmpeg.readFile(`output.${outputFileType}`);\n    if (outputFileType == 'gif') {\n        const imgTag = document.createElement('img');\n        imgTag.src = URL.createObjectURL(new Blob([\n            data.buffer\n        ], {\n            type: 'image/gif'\n        }));\n        imgTag.classList.add('outputImg');\n        document.getElementById('output').firstChild.replaceWith(imgTag);\n    } else {\n        const sourceTag = document.createElement('source');\n        sourceTag.src = URL.createObjectURL(new Blob([\n            data.buffer\n        ], {\n            type: `video/${outputFileType}`\n        }));\n        const videoTag = document.createElement('video');\n        videoTag.setAttribute('controls', '');\n        videoTag.appendChild(sourceTag);\n        videoTag.classList.add('outputVideo');\n        document.getElementById('output').firstChild.replaceWith(videoTag);\n    }\n};\nasync function $c1ce9d969bfa6909$var$createFileFromUrl(url, filename, mimeType) {\n    try {\n        const response = await fetch(url);\n        const blob = await response.blob();\n        return new File([\n            blob\n        ], filename, {\n            type: mimeType\n        });\n    } catch (error) {\n        console.error(\"Error fetching or creating file:\", error);\n        return null;\n    }\n}\n// For testing only - useful if I want to have a default video so I don't have to select one every time.\nasync function $c1ce9d969bfa6909$var$processFetchedFile() {\n    const fileUrl = \"./thanks-i-hate-it.mp4\";\n    const fileName = \"thanks-i-hate-it.mp4\";\n    const fileMimeType = \"video/mp4\";\n    const myFile = await $c1ce9d969bfa6909$var$createFileFromUrl(fileUrl, fileName, fileMimeType);\n    return myFile;\n}\nconst $c1ce9d969bfa6909$var$handleInput = ()=>{\n    const file = document.getElementById('fileInput').files[0];\n    document.getElementById('output').firstChild.replaceWith(document.createElement('span'));\n    if (file.type == 'image/gif') {\n        const imgTag = document.createElement('img');\n        imgTag.src = URL.createObjectURL(file);\n        imgTag.classList.add('inputImg');\n        document.getElementById('originalFile').firstChild.replaceWith(imgTag);\n    } else {\n        const sourceTag = document.createElement('source');\n        sourceTag.src = URL.createObjectURL(file);\n        const videoTag = document.createElement('video');\n        videoTag.setAttribute('controls', '');\n        videoTag.appendChild(sourceTag);\n        videoTag.classList.add('inputVideo');\n        document.getElementById('originalFile').firstChild.replaceWith(videoTag);\n    }\n};\ndocument.addEventListener('DOMContentLoaded', async ()=>{\n    document.getElementById('startTranscode').addEventListener('click', $c1ce9d969bfa6909$var$transcode);\n    document.getElementById('chooseFile').addEventListener('click', ()=>{\n        document.getElementById('fileInput').click();\n    });\n    document.getElementById('fileInput').addEventListener('change', $c1ce9d969bfa6909$var$handleInput);\n});\n\n\n//# sourceMappingURL=index.294738fd.js.map\n","// From the actual documentation\r\nimport { FFmpeg } from '@ffmpeg/ffmpeg';\r\nimport { fetchFile, toBlobURL } from '@ffmpeg/util';\r\n\r\nffmpeg = new FFmpeg();\r\n//ffmpeg.on(\"log\", ({ message }) => { console.log(message); }); // If ffmpeg calls its log method, log that to the console.\r\nffmpeg.on(\"progress\", ({ progress, time }) => { document.getElementById('progress').textContent = `${(progress * 100).toFixed(2)} %, time: ${(time / 1000000).toFixed(2)} s`; }); // Show progress on the page.\r\n\r\nconst transcode = async () => {\r\n  /*  const baseURL = './';\r\n    await ffmpeg.load({\r\n      coreURL: await toBlobURL(`${baseURL}ffmpeg-core.js`, 'text/javascript'),\r\n      wasmURL: await toBlobURL(`${baseURL}ffmpeg-core.wasm`, 'application/wasm')\r\n    });*/\r\n\r\n  const baseURL = 'https://unpkg.com/@ffmpeg/core/dist/umd'\r\n  //const baseURL = \".\"\r\n  await ffmpeg.load({\r\n    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),\r\n    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),\r\n  });\r\n\r\n  // const file = await document.getElementById(\"fileInput\").files[0] ? await document.getElementById(\"fileInput\").files[0] : await processFetchedFile(); // With a default file for easy testing.\r\n  const file = await document.getElementById(\"fileInput\").files[0];\r\n  if (!file) { return }\r\n  const { name } = file;\r\n  const outputFileType = document.getElementById('outputType').value;\r\n  document.getElementById('output').firstChild.replaceWith(document.createElement('span'));\r\n  await ffmpeg.writeFile(name, await fetchFile(file));\r\n  document.getElementById('progress').textContent = 'Transcoding started';\r\n  console.log(`${new Date().toLocaleTimeString()} Transcoding started`);\r\n  await ffmpeg.exec(['-i', name, `output.${outputFileType}`]);\r\n  document.getElementById('progress').textContent = 'Transcoding ended';\r\n  console.log(`${new Date().toLocaleTimeString()} Transcoding ended`);\r\n  const data = await ffmpeg.readFile(`output.${outputFileType}`);\r\n  if (outputFileType == 'gif') {\r\n    const imgTag = document.createElement('img');\r\n    imgTag.src = URL.createObjectURL(new Blob([data.buffer], { type: 'image/gif' }));\r\n    imgTag.classList.add('outputImg');\r\n    document.getElementById('output').firstChild.replaceWith(imgTag);\r\n  } else {\r\n    const sourceTag = document.createElement('source');\r\n    sourceTag.src = URL.createObjectURL(new Blob([data.buffer], { type: `video/${outputFileType}` }));\r\n    const videoTag = document.createElement('video');\r\n    videoTag.setAttribute('controls', '');\r\n    videoTag.appendChild(sourceTag);\r\n    videoTag.classList.add('outputVideo')\r\n    document.getElementById('output').firstChild.replaceWith(videoTag);\r\n  }\r\n\r\n}\r\n\r\nasync function createFileFromUrl(url, filename, mimeType) {\r\n  try {\r\n    const response = await fetch(url);\r\n    const blob = await response.blob();\r\n    return new File([blob], filename, { type: mimeType });\r\n  } catch (error) {\r\n    console.error(\"Error fetching or creating file:\", error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// For testing only - useful if I want to have a default video so I don't have to select one every time.\r\nasync function processFetchedFile() {\r\n  const fileUrl = \"./thanks-i-hate-it.mp4\";\r\n  const fileName = \"thanks-i-hate-it.mp4\";\r\n  const fileMimeType = \"video/mp4\";\r\n\r\n  const myFile = await createFileFromUrl(fileUrl, fileName, fileMimeType);\r\n\r\n  return myFile;\r\n}\r\n\r\nconst handleInput = () => {\r\n  const file = document.getElementById('fileInput').files[0];\r\n  document.getElementById('output').firstChild.replaceWith(document.createElement('span'));\r\n  if (file.type == 'image/gif') {\r\n    const imgTag = document.createElement('img');\r\n    imgTag.src = URL.createObjectURL(file);\r\n    imgTag.classList.add('inputImg')\r\n    document.getElementById('originalFile').firstChild.replaceWith(imgTag);\r\n  } else {\r\n    const sourceTag = document.createElement('source');\r\n    sourceTag.src = URL.createObjectURL(file);\r\n    const videoTag = document.createElement('video');\r\n    videoTag.setAttribute('controls', '');\r\n    videoTag.appendChild(sourceTag);\r\n    videoTag.classList.add('inputVideo');\r\n    document.getElementById('originalFile').firstChild.replaceWith(videoTag);\r\n  }\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', async () => {\r\n  document.getElementById('startTranscode').addEventListener('click', transcode);\r\n  document.getElementById('chooseFile').addEventListener('click', () => {\r\n    document.getElementById('fileInput').click();\r\n  });\r\n  document.getElementById('fileInput').addEventListener('change', handleInput);\r\n});","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.FFmpegWASM=t():e.FFmpegWASM=t()}(self,(()=>(()=>{\"use strict\";var e={m:{},d:(t,s)=>{for(var r in s)e.o(s,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:s[r]})},u:e=>e+\".ffmpeg.js\"};e.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(e){if(\"object\"==typeof window)return window}}(),e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e.r=e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},(()=>{var t;e.g.importScripts&&(t=e.g.location+\"\");var s=e.g.document;if(!t&&s&&(s.currentScript&&(t=s.currentScript.src),!t)){var r=s.getElementsByTagName(\"script\");if(r.length)for(var a=r.length-1;a>-1&&!t;)t=r[a--].src}if(!t)throw new Error(\"Automatic publicPath is not supported in this browser\");t=t.replace(/#.*$/,\"\").replace(/\\?.*$/,\"\").replace(/\\/[^\\/]+$/,\"/\"),e.p=t})(),e.b=document.baseURI||self.location.href;var t,s={};e.r(s),e.d(s,{FFFSType:()=>n,FFmpeg:()=>i}),function(e){e.LOAD=\"LOAD\",e.EXEC=\"EXEC\",e.FFPROBE=\"FFPROBE\",e.WRITE_FILE=\"WRITE_FILE\",e.READ_FILE=\"READ_FILE\",e.DELETE_FILE=\"DELETE_FILE\",e.RENAME=\"RENAME\",e.CREATE_DIR=\"CREATE_DIR\",e.LIST_DIR=\"LIST_DIR\",e.DELETE_DIR=\"DELETE_DIR\",e.ERROR=\"ERROR\",e.DOWNLOAD=\"DOWNLOAD\",e.PROGRESS=\"PROGRESS\",e.LOG=\"LOG\",e.MOUNT=\"MOUNT\",e.UNMOUNT=\"UNMOUNT\"}(t||(t={}));const r=(()=>{let e=0;return()=>e++})(),a=(new Error(\"unknown message type\"),new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\")),o=new Error(\"called FFmpeg.terminate()\");new Error(\"failed to import ffmpeg-core.js\");class i{#e=null;#t={};#s={};#r=[];#a=[];loaded=!1;#o=()=>{this.#e&&(this.#e.onmessage=({data:{id:e,type:s,data:r}})=>{switch(s){case t.LOAD:this.loaded=!0,this.#t[e](r);break;case t.MOUNT:case t.UNMOUNT:case t.EXEC:case t.FFPROBE:case t.WRITE_FILE:case t.READ_FILE:case t.DELETE_FILE:case t.RENAME:case t.CREATE_DIR:case t.LIST_DIR:case t.DELETE_DIR:this.#t[e](r);break;case t.LOG:this.#r.forEach((e=>e(r)));break;case t.PROGRESS:this.#a.forEach((e=>e(r)));break;case t.ERROR:this.#s[e](r)}delete this.#t[e],delete this.#s[e]})};#i=({type:e,data:t},s=[],o)=>this.#e?new Promise(((a,i)=>{const n=r();this.#e&&this.#e.postMessage({id:n,type:e,data:t},s),this.#t[n]=a,this.#s[n]=i,o?.addEventListener(\"abort\",(()=>{i(new DOMException(`Message # ${n} was aborted`,\"AbortError\"))}),{once:!0})})):Promise.reject(a);on(e,t){\"log\"===e?this.#r.push(t):\"progress\"===e&&this.#a.push(t)}off(e,t){\"log\"===e?this.#r=this.#r.filter((e=>e!==t)):\"progress\"===e&&(this.#a=this.#a.filter((e=>e!==t)))}load=({classWorkerURL:s,...r}={},{signal:a}={})=>(this.#e||(this.#e=s?new Worker(new URL(s,\"file:///Users/focus/Projects/ffmpeg.wasm/packages/ffmpeg/dist/esm/classes.js\"),{type:\"module\"}):new Worker(new URL(e.p+e.u(814),e.b),{type:void 0}),this.#o()),this.#i({type:t.LOAD,data:r},void 0,a));exec=(e,s=-1,{signal:r}={})=>this.#i({type:t.EXEC,data:{args:e,timeout:s}},void 0,r);ffprobe=(e,s=-1,{signal:r}={})=>this.#i({type:t.FFPROBE,data:{args:e,timeout:s}},void 0,r);terminate=()=>{const e=Object.keys(this.#s);for(const t of e)this.#s[t](o),delete this.#s[t],delete this.#t[t];this.#e&&(this.#e.terminate(),this.#e=null,this.loaded=!1)};writeFile=(e,s,{signal:r}={})=>{const a=[];return s instanceof Uint8Array&&a.push(s.buffer),this.#i({type:t.WRITE_FILE,data:{path:e,data:s}},a,r)};mount=(e,s,r)=>this.#i({type:t.MOUNT,data:{fsType:e,options:s,mountPoint:r}},[]);unmount=e=>this.#i({type:t.UNMOUNT,data:{mountPoint:e}},[]);readFile=(e,s=\"binary\",{signal:r}={})=>this.#i({type:t.READ_FILE,data:{path:e,encoding:s}},void 0,r);deleteFile=(e,{signal:s}={})=>this.#i({type:t.DELETE_FILE,data:{path:e}},void 0,s);rename=(e,s,{signal:r}={})=>this.#i({type:t.RENAME,data:{oldPath:e,newPath:s}},void 0,r);createDir=(e,{signal:s}={})=>this.#i({type:t.CREATE_DIR,data:{path:e}},void 0,s);listDir=(e,{signal:s}={})=>this.#i({type:t.LIST_DIR,data:{path:e}},void 0,s);deleteDir=(e,{signal:s}={})=>this.#i({type:t.DELETE_DIR,data:{path:e}},void 0,s)}var n;return function(e){e.MEMFS=\"MEMFS\",e.NODEFS=\"NODEFS\",e.NODERAWFS=\"NODERAWFS\",e.IDBFS=\"IDBFS\",e.WORKERFS=\"WORKERFS\",e.PROXYFS=\"PROXYFS\"}(n||(n={})),s})()));\n//# sourceMappingURL=ffmpeg.js.map","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FFmpegWASM\"] = factory();\n\telse\n\t\troot[\"FFmpegWASM\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".ffmpeg.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","export const MIME_TYPE_JAVASCRIPT = \"text/javascript\";\nexport const MIME_TYPE_WASM = \"application/wasm\";\nexport const CORE_VERSION = \"0.12.9\";\nexport const CORE_URL = `https://unpkg.com/@ffmpeg/core@${CORE_VERSION}/dist/umd/ffmpeg-core.js`;\nexport var FFMessageType;\n(function (FFMessageType) {\n    FFMessageType[\"LOAD\"] = \"LOAD\";\n    FFMessageType[\"EXEC\"] = \"EXEC\";\n    FFMessageType[\"FFPROBE\"] = \"FFPROBE\";\n    FFMessageType[\"WRITE_FILE\"] = \"WRITE_FILE\";\n    FFMessageType[\"READ_FILE\"] = \"READ_FILE\";\n    FFMessageType[\"DELETE_FILE\"] = \"DELETE_FILE\";\n    FFMessageType[\"RENAME\"] = \"RENAME\";\n    FFMessageType[\"CREATE_DIR\"] = \"CREATE_DIR\";\n    FFMessageType[\"LIST_DIR\"] = \"LIST_DIR\";\n    FFMessageType[\"DELETE_DIR\"] = \"DELETE_DIR\";\n    FFMessageType[\"ERROR\"] = \"ERROR\";\n    FFMessageType[\"DOWNLOAD\"] = \"DOWNLOAD\";\n    FFMessageType[\"PROGRESS\"] = \"PROGRESS\";\n    FFMessageType[\"LOG\"] = \"LOG\";\n    FFMessageType[\"MOUNT\"] = \"MOUNT\";\n    FFMessageType[\"UNMOUNT\"] = \"UNMOUNT\";\n})(FFMessageType || (FFMessageType = {}));\n","/**\n * Generate an unique message ID.\n */\nexport const getMessageID = (() => {\n    let messageID = 0;\n    return () => messageID++;\n})();\n","export const ERROR_UNKNOWN_MESSAGE_TYPE = new Error(\"unknown message type\");\nexport const ERROR_NOT_LOADED = new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\");\nexport const ERROR_TERMINATED = new Error(\"called FFmpeg.terminate()\");\nexport const ERROR_IMPORT_FAILURE = new Error(\"failed to import ffmpeg-core.js\");\n","import { FFMessageType } from \"./const.js\";\nimport { getMessageID } from \"./utils.js\";\nimport { ERROR_TERMINATED, ERROR_NOT_LOADED } from \"./errors.js\";\n/**\n * Provides APIs to interact with ffmpeg web worker.\n *\n * @example\n * ```ts\n * const ffmpeg = new FFmpeg();\n * ```\n */\nexport class FFmpeg {\n    #worker = null;\n    /**\n     * #resolves and #rejects tracks Promise resolves and rejects to\n     * be called when we receive message from web worker.\n     */\n    #resolves = {};\n    #rejects = {};\n    #logEventCallbacks = [];\n    #progressEventCallbacks = [];\n    loaded = false;\n    /**\n     * register worker message event handlers.\n     */\n    #registerHandlers = () => {\n        if (this.#worker) {\n            this.#worker.onmessage = ({ data: { id, type, data }, }) => {\n                switch (type) {\n                    case FFMessageType.LOAD:\n                        this.loaded = true;\n                        this.#resolves[id](data);\n                        break;\n                    case FFMessageType.MOUNT:\n                    case FFMessageType.UNMOUNT:\n                    case FFMessageType.EXEC:\n                    case FFMessageType.FFPROBE:\n                    case FFMessageType.WRITE_FILE:\n                    case FFMessageType.READ_FILE:\n                    case FFMessageType.DELETE_FILE:\n                    case FFMessageType.RENAME:\n                    case FFMessageType.CREATE_DIR:\n                    case FFMessageType.LIST_DIR:\n                    case FFMessageType.DELETE_DIR:\n                        this.#resolves[id](data);\n                        break;\n                    case FFMessageType.LOG:\n                        this.#logEventCallbacks.forEach((f) => f(data));\n                        break;\n                    case FFMessageType.PROGRESS:\n                        this.#progressEventCallbacks.forEach((f) => f(data));\n                        break;\n                    case FFMessageType.ERROR:\n                        this.#rejects[id](data);\n                        break;\n                }\n                delete this.#resolves[id];\n                delete this.#rejects[id];\n            };\n        }\n    };\n    /**\n     * Generic function to send messages to web worker.\n     */\n    #send = ({ type, data }, trans = [], signal) => {\n        if (!this.#worker) {\n            return Promise.reject(ERROR_NOT_LOADED);\n        }\n        return new Promise((resolve, reject) => {\n            const id = getMessageID();\n            this.#worker && this.#worker.postMessage({ id, type, data }, trans);\n            this.#resolves[id] = resolve;\n            this.#rejects[id] = reject;\n            signal?.addEventListener(\"abort\", () => {\n                reject(new DOMException(`Message # ${id} was aborted`, \"AbortError\"));\n            }, { once: true });\n        });\n    };\n    on(event, callback) {\n        if (event === \"log\") {\n            this.#logEventCallbacks.push(callback);\n        }\n        else if (event === \"progress\") {\n            this.#progressEventCallbacks.push(callback);\n        }\n    }\n    off(event, callback) {\n        if (event === \"log\") {\n            this.#logEventCallbacks = this.#logEventCallbacks.filter((f) => f !== callback);\n        }\n        else if (event === \"progress\") {\n            this.#progressEventCallbacks = this.#progressEventCallbacks.filter((f) => f !== callback);\n        }\n    }\n    /**\n     * Loads ffmpeg-core inside web worker. It is required to call this method first\n     * as it initializes WebAssembly and other essential variables.\n     *\n     * @category FFmpeg\n     * @returns `true` if ffmpeg core is loaded for the first time.\n     */\n    load = ({ classWorkerURL, ...config } = {}, { signal } = {}) => {\n        if (!this.#worker) {\n            this.#worker = classWorkerURL ?\n                new Worker(new URL(classWorkerURL, import.meta.url), {\n                    type: \"module\",\n                }) :\n                // We need to duplicated the code here to enable webpack\n                // to bundle worekr.js here.\n                new Worker(new URL(\"./worker.js\", import.meta.url), {\n                    type: \"module\",\n                });\n            this.#registerHandlers();\n        }\n        return this.#send({\n            type: FFMessageType.LOAD,\n            data: config,\n        }, undefined, signal);\n    };\n    /**\n     * Execute ffmpeg command.\n     *\n     * @remarks\n     * To avoid common I/O issues, [\"-nostdin\", \"-y\"] are prepended to the args\n     * by default.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", ...);\n     * // ffmpeg -i video.avi video.mp4\n     * await ffmpeg.exec([\"-i\", \"video.avi\", \"video.mp4\"]);\n     * const data = ffmpeg.readFile(\"video.mp4\");\n     * ```\n     *\n     * @returns `0` if no error, `!= 0` if timeout (1) or error.\n     * @category FFmpeg\n     */\n    exec = (\n    /** ffmpeg command line args */\n    args, \n    /**\n     * milliseconds to wait before stopping the command execution.\n     *\n     * @defaultValue -1\n     */\n    timeout = -1, { signal } = {}) => this.#send({\n        type: FFMessageType.EXEC,\n        data: { args, timeout },\n    }, undefined, signal);\n    /**\n     * Execute ffprobe command.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", ...);\n     * // Getting duration of a video in seconds: ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 video.avi -o output.txt\n     * await ffmpeg.ffprobe([\"-v\", \"error\", \"-show_entries\", \"format=duration\", \"-of\", \"default=noprint_wrappers=1:nokey=1\", \"video.avi\", \"-o\", \"output.txt\"]);\n     * const data = ffmpeg.readFile(\"output.txt\");\n     * ```\n     *\n     * @returns `0` if no error, `!= 0` if timeout (1) or error.\n     * @category FFmpeg\n     */\n    ffprobe = (\n    /** ffprobe command line args */\n    args, \n    /**\n     * milliseconds to wait before stopping the command execution.\n     *\n     * @defaultValue -1\n     */\n    timeout = -1, { signal } = {}) => this.#send({\n        type: FFMessageType.FFPROBE,\n        data: { args, timeout },\n    }, undefined, signal);\n    /**\n     * Terminate all ongoing API calls and terminate web worker.\n     * `FFmpeg.load()` must be called again before calling any other APIs.\n     *\n     * @category FFmpeg\n     */\n    terminate = () => {\n        const ids = Object.keys(this.#rejects);\n        // rejects all incomplete Promises.\n        for (const id of ids) {\n            this.#rejects[id](ERROR_TERMINATED);\n            delete this.#rejects[id];\n            delete this.#resolves[id];\n        }\n        if (this.#worker) {\n            this.#worker.terminate();\n            this.#worker = null;\n            this.loaded = false;\n        }\n    };\n    /**\n     * Write data to ffmpeg.wasm.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", await fetchFile(\"../video.avi\"));\n     * await ffmpeg.writeFile(\"text.txt\", \"hello world\");\n     * ```\n     *\n     * @category File System\n     */\n    writeFile = (path, data, { signal } = {}) => {\n        const trans = [];\n        if (data instanceof Uint8Array) {\n            trans.push(data.buffer);\n        }\n        return this.#send({\n            type: FFMessageType.WRITE_FILE,\n            data: { path, data },\n        }, trans, signal);\n    };\n    mount = (fsType, options, mountPoint) => {\n        const trans = [];\n        return this.#send({\n            type: FFMessageType.MOUNT,\n            data: { fsType, options, mountPoint },\n        }, trans);\n    };\n    unmount = (mountPoint) => {\n        const trans = [];\n        return this.#send({\n            type: FFMessageType.UNMOUNT,\n            data: { mountPoint },\n        }, trans);\n    };\n    /**\n     * Read data from ffmpeg.wasm.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * const data = await ffmpeg.readFile(\"video.mp4\");\n     * ```\n     *\n     * @category File System\n     */\n    readFile = (path, \n    /**\n     * File content encoding, supports two encodings:\n     * - utf8: read file as text file, return data in string type.\n     * - binary: read file as binary file, return data in Uint8Array type.\n     *\n     * @defaultValue binary\n     */\n    encoding = \"binary\", { signal } = {}) => this.#send({\n        type: FFMessageType.READ_FILE,\n        data: { path, encoding },\n    }, undefined, signal);\n    /**\n     * Delete a file.\n     *\n     * @category File System\n     */\n    deleteFile = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.DELETE_FILE,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * Rename a file or directory.\n     *\n     * @category File System\n     */\n    rename = (oldPath, newPath, { signal } = {}) => this.#send({\n        type: FFMessageType.RENAME,\n        data: { oldPath, newPath },\n    }, undefined, signal);\n    /**\n     * Create a directory.\n     *\n     * @category File System\n     */\n    createDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.CREATE_DIR,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * List directory contents.\n     *\n     * @category File System\n     */\n    listDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.LIST_DIR,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * Delete an empty directory.\n     *\n     * @category File System\n     */\n    deleteDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.DELETE_DIR,\n        data: { path },\n    }, undefined, signal);\n}\n","export var FFFSType;\n(function (FFFSType) {\n    FFFSType[\"MEMFS\"] = \"MEMFS\";\n    FFFSType[\"NODEFS\"] = \"NODEFS\";\n    FFFSType[\"NODERAWFS\"] = \"NODERAWFS\";\n    FFFSType[\"IDBFS\"] = \"IDBFS\";\n    FFFSType[\"WORKERFS\"] = \"WORKERFS\";\n    FFFSType[\"PROXYFS\"] = \"PROXYFS\";\n})(FFFSType || (FFFSType = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toBlobURL = exports.downloadWithProgress = exports.importScript = exports.fetchFile = void 0;\nconst errors_js_1 = require(\"./errors.js\");\nconst const_js_1 = require(\"./const.js\");\nconst readFromBlobOrFile = (blob) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        const { result } = fileReader;\n        if (result instanceof ArrayBuffer) {\n            resolve(new Uint8Array(result));\n        }\n        else {\n            resolve(new Uint8Array());\n        }\n    };\n    fileReader.onerror = (event) => {\n        var _a, _b;\n        reject(Error(`File could not be read! Code=${((_b = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.code) || -1}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n});\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */\nconst fetchFile = (file) => __awaiter(void 0, void 0, void 0, function* () {\n    let data;\n    if (typeof file === \"string\") {\n        /* From base64 format */\n        if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) {\n            data = atob(file.split(\",\")[1])\n                .split(\"\")\n                .map((c) => c.charCodeAt(0));\n            /* From remote server/URL */\n        }\n        else {\n            data = yield (yield fetch(file)).arrayBuffer();\n        }\n    }\n    else if (file instanceof URL) {\n        data = yield (yield fetch(file)).arrayBuffer();\n    }\n    else if (file instanceof File || file instanceof Blob) {\n        data = yield readFromBlobOrFile(file);\n    }\n    else {\n        return new Uint8Array();\n    }\n    return new Uint8Array(data);\n});\nexports.fetchFile = fetchFile;\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */\nconst importScript = (url) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        const script = document.createElement(\"script\");\n        const eventHandler = () => {\n            script.removeEventListener(\"load\", eventHandler);\n            resolve();\n        };\n        script.src = url;\n        script.type = \"text/javascript\";\n        script.addEventListener(\"load\", eventHandler);\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    });\n});\nexports.importScript = importScript;\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */\nconst downloadWithProgress = (url, cb) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    const resp = yield fetch(url);\n    let buf;\n    try {\n        // Set total to -1 to indicate that there is not Content-Type Header.\n        const total = parseInt(resp.headers.get(const_js_1.HeaderContentLength) || \"-1\");\n        const reader = (_a = resp.body) === null || _a === void 0 ? void 0 : _a.getReader();\n        if (!reader)\n            throw errors_js_1.ERROR_RESPONSE_BODY_READER;\n        const chunks = [];\n        let received = 0;\n        for (;;) {\n            const { done, value } = yield reader.read();\n            const delta = value ? value.length : 0;\n            if (done) {\n                if (total != -1 && total !== received)\n                    throw errors_js_1.ERROR_INCOMPLETED_DOWNLOAD;\n                cb && cb({ url, total, received, delta, done });\n                break;\n            }\n            chunks.push(value);\n            received += delta;\n            cb && cb({ url, total, received, delta, done });\n        }\n        const data = new Uint8Array(received);\n        let position = 0;\n        for (const chunk of chunks) {\n            data.set(chunk, position);\n            position += chunk.length;\n        }\n        buf = data.buffer;\n    }\n    catch (e) {\n        console.log(`failed to send download progress event: `, e);\n        // Fetch arrayBuffer directly when it is not possible to get progress.\n        buf = yield resp.arrayBuffer();\n        cb &&\n            cb({\n                url,\n                total: buf.byteLength,\n                received: buf.byteLength,\n                delta: 0,\n                done: true,\n            });\n    }\n    return buf;\n});\nexports.downloadWithProgress = downloadWithProgress;\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */\nconst toBlobURL = (url, mimeType, progress = false, cb) => __awaiter(void 0, void 0, void 0, function* () {\n    const buf = progress\n        ? yield (0, exports.downloadWithProgress)(url, cb)\n        : yield (yield fetch(url)).arrayBuffer();\n    const blob = new Blob([buf], { type: mimeType });\n    return URL.createObjectURL(blob);\n});\nexports.toBlobURL = toBlobURL;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_INCOMPLETED_DOWNLOAD = exports.ERROR_RESPONSE_BODY_READER = void 0;\nexports.ERROR_RESPONSE_BODY_READER = new Error(\"failed to get response body reader\");\nexports.ERROR_INCOMPLETED_DOWNLOAD = new Error(\"failed to complete download\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeaderContentLength = void 0;\nexports.HeaderContentLength = \"Content-Length\";\n"],"names":["e","$f3794c4d073fcecf$exports","self","n","m","d","t","s","r","o","Object","defineProperty","enumerable","get","u","g","globalThis","Function","window","prototype","hasOwnProperty","call","Symbol","toStringTag","value","importScripts","location","document","currentScript","src","getElementsByTagName","length","a","Error","p","replace","b","baseURI","href","FFFSType","FFmpeg","i","LOAD","EXEC","FFPROBE","WRITE_FILE","READ_FILE","DELETE_FILE","RENAME","CREATE_DIR","LIST_DIR","DELETE_DIR","ERROR","DOWNLOAD","PROGRESS","LOG","MOUNT","UNMOUNT","loaded","onmessage","data","id","type","forEach","Promise","postMessage","addEventListener","DOMException","once","reject","on","push","off","filter","load","classWorkerURL","signal","Worker","URL","exec","args","timeout","ffprobe","terminate","keys","writeFile","Uint8Array","buffer","path","mount","fsType","options","mountPoint","unmount","readFile","encoding","deleteFile","rename","oldPath","newPath","createDir","listDir","deleteDir","MEMFS","NODEFS","NODERAWFS","IDBFS","WORKERFS","PROXYFS","$8e792f90c5959bce$exports","$8e792f90c5959bce$var$__awaiter","__awaiter","thisArg","_arguments","P","generator","resolve","fulfilled","step","next","rejected","result","done","adopt","then","apply","toBlobURL","downloadWithProgress","importScript","fetchFile","$908c7b43e3e5d3cb$exports","ERROR_INCOMPLETED_DOWNLOAD","ERROR_RESPONSE_BODY_READER","$3a36a17f95d15b42$exports","HeaderContentLength","$8e792f90c5959bce$var$readFromBlobOrFile","blob","fileReader","FileReader","onload","ArrayBuffer","onerror","event","_a","_b","target","error","code","readAsArrayBuffer","file","test","atob","split","map","c","charCodeAt","fetch","arrayBuffer","File","Blob","url","script","createElement","eventHandler","removeEventListener","appendChild","cb","buf","resp","total","parseInt","headers","reader","body","getReader","chunks","received","read","delta","position","chunk","set","console","log","byteLength","mimeType","progress","createObjectURL","ffmpeg","time","getElementById","textContent","toFixed","$c1ce9d969bfa6909$var$transcode","baseURL","coreURL","wasmURL","files","name","outputFileType","firstChild","replaceWith","Date","toLocaleTimeString","imgTag","classList","add","sourceTag","videoTag","setAttribute","$c1ce9d969bfa6909$var$handleInput","click","root","factory","exports","module","define","amd","__webpack_require__","definition","key","chunkId","this","obj","prop","scriptUrl","scripts","FFMessageType","getMessageID","messageID","ERROR_NOT_LOADED","ERROR_TERMINATED","f","trans","callback","config","undefined","ids"],"version":3,"file":"index.294738fd.js.map"}